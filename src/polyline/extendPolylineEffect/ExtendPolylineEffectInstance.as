package polyline.extendPolylineEffect
{
	import com.esri.ags.Graphic;
	import com.esri.ags.geometry.MapPoint;
	import com.esri.ags.geometry.Polyline;
	
	import mx.effects.Tween;
	import mx.effects.effectClasses.TweenEffectInstance;

	public class ExtendPolylineEffectInstance extends TweenEffectInstance
	{
		public var pctStart:Number;
		public var pctEnd:Number;
		public var alsoAnimateAlpha:Boolean;
		public var playReverseDirection:Boolean;
		public var pathInfos:Array; // of PathInfo
		private var _nTargetTotalLength:Number;
		private var _geomOriginal:Polyline;
		
		public function ExtendPolylineEffectInstance(target:Graphic)
		{
			super(target);
		}
		
		override public function set target( value:Object ):void {
			_geomOriginal = ( value as Graphic ).geometry as Polyline;
			super.target = value;
		}
	
		
		override public function play():void {
			super.play();
			// Create a tween object to control the effect
			var tween:Tween = createTween( this, pctStart, pctEnd, duration );
		}	
			
		/**
		 * 	Make updates to target object:
		 *	interpolate a set of temporary, intermediate paths, each of which
		 *	is <i>value</i> percent of the length of the full path.
		 * @param value - percentage (0 to 100) of the path length to show (generated by Tween mechanism)
		 **/ 
		override public function onTweenUpdate(value:Object):void {
			var nValue:Number = value as Number;
			var g:Graphic = target as Graphic;
			var plGeom:Polyline = new Polyline( [], g.geometry.spatialReference );
			
			for each ( var oPath:Object in pathInfos ) {
				var nRequestedPathLen:Number = oPath.pathLength * ( nValue / 100 );
				var nCurrentPathLen:Number = 0; // Length of path-being-constructed
				var aryPathPts:Array = [];
				
				for ( var iSegment:int = 0; iSegment < oPath.segmentInfos.length; iSegment++ ) {
					var oSegment:Object = oPath.segmentInfos[ iSegment ];
					
					var ptSegmentStart:MapPoint = oSegment.startPoint; 
					var ptSegmentEnd:MapPoint = oSegment.endPoint;
					var nCurrentSegmentLen:Number = oSegment.segmentLength;
					
					if ( iSegment == 0 ) aryPathPts.push( oSegment.startPoint );

					// If this segment won't complete the requested percentage of the total path,
					// add the whole segment
					if ( nCurrentPathLen + nCurrentSegmentLen < nRequestedPathLen ) {
						aryPathPts.push( ptSegmentEnd );
						nCurrentPathLen += nCurrentSegmentLen;
					}
					// If this segment will complete or surpass the requested percentage of the total line,
					// it's the last segment; calculate the proper percentage to add
					else {
						var nPathLenStillNeeded:Number =  nRequestedPathLen - nCurrentPathLen;
						var nPctOfThisPathNeeded:Number = nPathLenStillNeeded / nCurrentSegmentLen;
						var nDeltaX:Number = (ptSegmentEnd.x - ptSegmentStart.x) * nPctOfThisPathNeeded;
						var nDeltaY:Number = (ptSegmentEnd.y - ptSegmentStart.y) * nPctOfThisPathNeeded;
						var ptNewEnd:MapPoint = new MapPoint(ptSegmentStart.x + nDeltaX, ptSegmentStart.y + nDeltaY);
						aryPathPts.push( ptNewEnd );
						
						// And exit the loop
						break;
					}
				}
				plGeom.paths.push( aryPathPts );
			}
			
			// Assume target is an already-instantiated graphic; we just replace the coords
			g.geometry = plGeom;
			
			if ( alsoAnimateAlpha ) g.alpha = Number(value) / 100;
		}
		
		override public function onTweenEnd(value:Object):void {
			super.onTweenEnd(value);
			(target as Graphic).geometry = _geomOriginal;
		}
		
		public function gatherPolylineInfo():void {			
			// Gather info on each path and segment
			var pln:Polyline = (target as Graphic).geometry as Polyline;
			pathInfos = [];
			
			for ( var iPath:int = 0; iPath < pln.paths.length; iPath++ ) {
				var aryPath:Array = pln.paths[ iPath ];
				var arySegmentsForPath:Array = [];
				var nPathLen:Number = 0;
				
				// Store each pair of points in the path, plus the distance between them
				// Construct the segments in reverse order and direction if playReverseDirection == true
				for ( var iPathPt:int = 1; iPathPt < aryPath.length; iPathPt++ ) {
					var ptStart:MapPoint = playReverseDirection ? aryPath[ iPathPt ] : aryPath[ iPathPt - 1 ];
					var ptEnd:MapPoint = playReverseDirection ? aryPath[ iPathPt - 1 ] : aryPath[ iPathPt ];
					
					var nSegmentLen:Number = segmentLength( ptStart, ptEnd );					
					arySegmentsForPath.push( {
						"startPoint"	: ptStart,
						"endPoint"		: ptEnd,
						"segmentLength"	: nSegmentLen
					} );
					nPathLen += nSegmentLen;
				}
				
				if ( playReverseDirection ) arySegmentsForPath.reverse();
				
				pathInfos.push( {
					"segmentInfos"		: arySegmentsForPath,
					"pathLength"		: nPathLen
				} );
			}
		}
		/**
		 * Calculates the length of a portion of a polyline using the Pythagorean theorem
		 * This won't work well if crossing the date line or a pole...
		 * @param ptStart - Starting point of the segment
		 * @param ptEnd   - Ending point of the segment
		 * @return Distance between the start and end points
		 **/ 
		private function segmentLength( ptStart:MapPoint, ptEnd:MapPoint ):Number {
			return Math.sqrt( Math.pow( ptEnd.x - ptStart.x, 2 ) + Math.pow( ptEnd.y - ptStart.y, 2 ) );
		}
		
	}
}